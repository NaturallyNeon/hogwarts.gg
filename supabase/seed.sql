drop type public.app_permission;
drop type public.app_role;
drop type public.app_node_type;
create type public.app_permission as enum ('nodes.delete', 'nodes.edit');
create type public.app_role as enum ('admin', 'moderator');
create type public.app_node_type as enum ('chest');

-- USERS
create table public.users (
  id          uuid not null primary key, -- UUID from auth.users
  username    text
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal Supabase Auth user.';

-- CHANNELS
create table public.nodes (
  id            bigint generated by default as identity primary key,
  updated_at   timestamp with time zone default timezone('utc'::text, now()) not null,
  title          text not null,
  description          text not null,
  type          app_node_type not null,
  latLng integer[2] not null,
  created_by    uuid references public.users not null
);
comment on table public.nodes is 'Nodes.';

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- authorize with role-based access control (RBAC)
create function public.authorize(
  requested_permission app_permission,
  user_id uuid
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  inner join public.user_roles on role_permissions.role = user_roles.role
  where role_permissions.permission = authorize.requested_permission
    and user_roles.user_id = authorize.user_id
  into bind_permissions;
  
  return bind_permissions > 0;
end;
$$ language plpgsql security definer;

-- Secure the tables
alter table public.users enable row level security;
alter table public.nodes enable row level security;
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
create policy "Allow everyone read access" on public.users for select using ( true );
create policy "Allow individual insert access" on public.users for insert with check ( auth.uid() = id );
create policy "Allow individual update access" on public.users for update using ( auth.uid() = id );
create policy "Allow everyone read access" on public.nodes for select using ( true );
create policy "Allow individual insert access" on public.nodes for insert with check ( auth.uid() = created_by );
create policy "Allow individual update access" on public.nodes for update using ( auth.uid() = created_by );
create policy "Allow individual delete access" on public.nodes for delete using ( auth.uid() = created_by );
create policy "Allow authorized update access" on public.nodes for delete using ( authorize('nodes.edit', auth.uid()) );
create policy "Allow authorized delete access" on public.nodes for delete using ( authorize('nodes.delete', auth.uid()) );
create policy "Allow everyone read access" on public.user_roles for select using ( true );

-- Send "previous data" on change 
alter table public.users replica identity full; 
alter table public.nodes replica identity full; 

-- inserts a row into public.users and assigns roles
drop trigger IF EXISTS on_auth_user_created on auth.users;
drop function public.handle_new_user;
create function public.handle_new_user() 
returns trigger as $$
declare is_admin boolean;
begin
  insert into public.users (id, username)
  values (new.id, new.email);
  
  -- first authorized user will be the admin
  select count(*) = 1 from auth.users into is_admin;

  return new;
end;
$$ language plpgsql security definer;

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

/**
 * REALTIME SUBSCRIPTIONS
 * Only allow realtime listening on public tables.
 */

begin; 
  -- remove the realtime publication
  drop publication if exists supabase_realtime; 

  -- re-create the publication but don't enable it for any tables
  create publication supabase_realtime;  
commit;

-- add tables to the publication
alter publication supabase_realtime add table public.nodes;
alter publication supabase_realtime add table public.users;

-- DUMMY DATA
insert into public.role_permissions (role, permission)
values
    ('admin', 'nodes.delete'),
    ('admin', 'nodes.edit'),
    ('moderator', 'nodes.edit'),
    ('moderator', 'nodes.delete');

